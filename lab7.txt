Лабораторна робота №7
Створення веб застосунку та налаштування базової авторизації
Мета: Ознайомитись з основними методами створення React додатків та налаштування
базової авторизації та маршрутизації сторінок.
7.1 Теоретичні відомості
Компонент у React — це базова одиниця побудови інтерфейсу, логічно завершений
фрагмент UI, який поєднує в собі розмітку, поведінку та, за потреби, стан. З формальної точки
зору сучасний React-компонент — це звичайна JavaScript/TypeScript-функція, яка приймає
вхідні дані (props) і повертає опис інтерфейсу в вигляді JSX. Уся програма в React
розглядається як дерево компонентів, де кореневий компонент (зазвичай App) містить інші
компоненти, а ті, своєю чергою, можуть включати ще дрібніші. Таким чином утворюється
ієрархічна структура, в якій кожен вузол відповідає за власну ділянку інтерфейсу та
інкапсулює пов’язану з нею логіку.
function MyComponent(props) {
return <div>...</div>;
}
JSX, який повертає компонент, є декларативним описом того, як має виглядати
інтерфейс у конкретний момент часу. Це не HTML, а синтаксичний цукор над викликами
React.createElement, який дозволяє описувати структуру UI засобами мови
JavaScript/TypeScript. У JSX кожен компонент позначається тегом з назвою, що починається з
великої літери. Це принципове правило: теги, які починаються з малої літери, трактуються як
елементи DOM (наприклад, div, button), а теги з великої — як користувацькі компоненти
(LoginForm, Dashboard). Кожен компонент у JSX повинен повертати один кореневий елемент
(або фрагмент), тому вся структура, яку він описує, логічно згрупована в єдиний вузол. React
будує внутрішнє представлення цього дерева (так званий Virtual DOM) і, при зміні стану чи
вхідних даних, обчислює мінімальний набір змін, які потрібно застосувати до реального DOM
у браузері.
const element = <h1>Hello, React</h1>;
Один компонент повертає один кореневий елемент (можна використовувати <>...</>
– React Fragment); JSX працює не з реальним DOM, а з віртуальним DOM (Virtual DOM),
який React синхронізує з браузером.
Вхідні дані компонента називаються props (properties). З теоретичної точки зору, props
— це параметри функції-компонента. Вони задають зовнішній інтерфейс компонента: які дані
він очікує отримати “ззовні”, які значення вміє відображати, які callback-функції викликати у
відповідь на події. Потік даних у React за замовчуванням односторонній: батьківський
компонент передає props дочірньому, тобто дані рухаються згори вниз по дереву компонентів.
Сам компонент не має права змінювати свої props, він лише їх читає і на їх основі формує JSX.
Це забезпечує передбачуваність: якщо компонент розглядати абстрактно як математичну
функцію UI = f(props, state), то props — це одна з вхідних змінних, контрольована оточенням,
а не самим компонентом.
type ButtonProps = {
label: string;
};
export const Button: React.FC<ButtonProps> = ({ label }) => {
return <button>{label}</button>;
};
<Button label="Login" />
<Button label="Register" />
Окремим важливим аспектом є побічні ефекти та життєвий цикл компонента. Сам по
собі акт рендерингу (обчислення JSX) має бути по можливості “чистим”, тобто без
безпосередніх побічних дій: не варто всередині тіла компонента виконувати запити до мережі,
запис в localStorage, прямі маніпуляції DOM тощо. Для цього в функціональних компонентах
використовується хук useEffect, який дозволяє заявити ефект, що повинен бути виконаний
після рендерингу або при зміні певних залежностей. У термінах життєвого циклу це те місце,
де компонент “взаємодіє з зовнішнім світом”: завантажує дані з API, підписується на події,
налаштовує таймери, а при демонтажі — скасовує підписки, очищує ресурси. Теоретично
useEffect дає можливість чітко розділити обчислювальну частину компонента (перетворення
props + state у JSX) і частину, пов’язану з побічними діями.
import { useEffect, useState } from "react";
export const HealthStatus: React.FC = () => {
const [status, setStatus] = useState("checking...");
useEffect(() => {
fetch("/api/health_check")
.then((res) => res.json())
.then(() => setStatus("online"))
.catch(() => setStatus("offline"));
}, []); // [] означає: виконати ефект один раз після першого рендеру
return <div>API status: {status}</div>;
};
Створення компонентів у React тісно пов’язане з принципом композиції. Ідея полягає в
тому, що замість написання монолітних блоків інтерфейсу, де у одному фрагменті коду
змішуються розмітка, логіка, стилі та взаємодія з сервером, застосунок ділиться на невеликі,
добре визначені компоненти. Кожен з них відповідає за конкретний фрагмент UI (наприклад,
форма авторизації, навігаційна панель, картка користувача, блок дашборду) і може бути
перевикористаний у різних місцях. Це відповідає загальним принципам модульності та
повторного використання в програмуванні: компонент виступає як модуль з чітким
контрактом (описаний через тип props), а вся система — як композиція таких модулів.
export const Page: React.FC = () => {
return (
<>
<Header />
<Dashboard />
<Footer />
</>
);
};
Ще один важливий теоретичний момент — це використання props.children для
реалізації композиції “вмісту в контейнері”. Компонент може не лише отримувати набір явних
параметрів (рядки, числа, callback-функції), але й приймати як вміст інші React-елементи.
Такий підхід дозволяє будувати абстракції на рівні макета: наприклад, створити універсальний
компонент Card, який визначає рамки, фон, заголовок, але не знає наперед, що саме буде
всередині. Цей внутрішній вміст передається йому як children. Теоретично це реалізація
патерна “інверсії контролю” в UI: батьківський компонент задає структуру, а конкретний вміст
підсовується йому ззовні, що робить систему максимально гнучкою.
fetch у сучасному JavaScript — це вбудований браузерний (і, частково, серверний у
оточенні типу Node з polyfill’ами) інтерфейс для виконання HTTP-запитів. Теоретично його
можна розглядати як абстракцію над мережевою взаємодією, яка реалізує модель “клієнт
надсилає запит – сервер повертає відповідь”, а з боку JS надає промісоорієнтований інтерфейс.
На відміну від старішого XMLHttpRequest, fetch має декларативніший синтаксис, працює
виключно асинхронно, повертає Promise, а також оперує чітко визначеними сутностями:
Request, Response, Headers, Body. Базовий виклик fetch(url) повертає Promise<Response>. Це
означає, що результатом є не “готові дані”, а об’єкт Response, який описує відповідь сервера:
статусний код, заголовки, тіло (body), методи для читання тіла в різних форматах (text(), json(),
blob() тощо). Важливий момент: проміс, який повертає fetch, переходить у стан fulfilled навіть
тоді, коли сервер відповів HTTP-помилкою (наприклад, 404 або 500). Для нього це “успішна
доставка HTTP-відповіді”, а не логічна помилка бізнес-рівня. Відхилення промісу (reject)
відбувається тільки при мережевих помилках (немає з’єднання, таймаут, зірваний TLS, CORS-
блокування тощо). Це принципова відмінність і важлива теоретична деталь: обробка HTTP-
коду статусу є окремою логікою, яку розробник має реалізовувати самостійно (наприклад,
перевіряючи response.ok або response.status).
Об’єкт Response, що повертається fetch, інкапсулює інформацію про статус відповіді
(status, statusText), заголовки (headers), а також тіло відповіді. Поле ok є зручним логічним
прапором, який дорівнює true, якщо статус коду знаходиться в діапазоні 200–299. Тіло
відповіді є потоковим (streaming) і реалізує інтерфейс Body. Теоретично тіло можна прочитати
тільки один раз: методи response.text(), response.json(), response.blob() повертають проміс, який
при першому виклику читає потік до кінця, і надалі тіло вважається спожитим. Це означає, що
повторно викликати інший метод для того самого Response не можна, якщо ви не клонували
його наперед (response.clone()). Така модель відповідає концепції одноразового читання
потоку й важлива з погляду ефективності та контролю над ресурсами. Другим ключовим
об’єктом є Request. Хоча найчастіше fetch викликають у короткій формі fetch(url, options),
теоретично під капотом можна створювати й явно передавати об’єкт Request, який описує
повний HTTP-запит: URL, метод (GET, POST, PUT, DELETE тощо), заголовки (Headers), тіло
(body), режим CORS, налаштування кешу, креденшіали (cookies, авторизація) тощо. У
параметрі options ми задаємо ці характеристики: method, headers, body, mode, credentials, cache,
redirect, referrerPolicy тощо. Headers при цьому є окремим об’єктом, який інкапсулює набір
HTTP-заголовків. Він реалізує інтерфейс ітерації та методи get, set, append, has, що дозволяє
працювати з заголовками як зі словником, але з урахуванням специфіки HTTP
(некейссенситивність ключів тощо).
Важливим теоретичним аспектом використання fetch є інтеграція з моделлю
асинхронного програмування в JS. Оскільки fetch повертає Promise, він природно поєднується
з async/await. З точки зору "сухої" теорії, async/await — це синтаксичне спрощення роботи з
промісами: ключове слово await дозволяє записати асинхронну операцію в стилі
“послідовного коду”, але під капотом усе так само залишається неблокуючим. Тому типовий
патерн обробки fetch виглядає як const response = await fetch(...); const data = await
response.json();. Тут перший await чекає приходу HTTP-відповіді, другий — повного читання
й парсингу тіла як JSON.
fetch тісно пов’язаний із політикою безпеки браузера, зокрема з same-origin policy та
CORS (Cross-Origin Resource Sharing). За замовчуванням браузер блокує спроби читати
відповіді з іншого домену, схеми чи порту, якщо сервер явно не дозволив це через CORS-
заголовки (Access-Control-Allow-Origin та інші). Параметр mode у fetch може бути cors, no-cors
або same-origin. У звичайному веб-застосунку типове значення — cors, яке дозволяє робити
кросдоменно запити, але доступ до відповіді буде дозволений тільки тоді, коли сервер
правильно налаштований на CORS. Параметр credentials визначає, чи будуть надсилатися кукі
та інші “облікові дані”: omit (не надсилати), same-origin (тільки для того ж походження) або
include (завжди надсилати, якщо не заборонено CORS). Теоретично це важливо, тому що fetch
за замовчуванням (на відміну від деяких старіших API) не завжди автоматично підставляє
cookies при кросдоменних запитах; контроль над цим винесено в параметр credentials, щоб
уникнути неочевидних витоків даних. Ще одна суттєва частина теорії — управління життєвим
циклом запиту. Стандартний fetch не має вбудованого таймаута, але дозволяє переривати
запит через AbortController. AbortController надає об’єкт signal, який передається в fetch; якщо
викликати controller.abort(), запит буде перервано, і проміс fetch перейде в стан відхилення з
помилкою типу DOMException з ім’ям "AbortError". Таким чином, у теоретичній моделі fetch
підтримує концепцію скасування (cancellation), що важливо для складних SPA, де користувач
може часто змінювати контекст (наприклад, швидко переходити між сторінками) і немає сенсу
завершувати старі запити.
На рівні протоколу fetch орієнтований на HTTP(S), але надає досить узагальнений
інтерфейс для роботи з запитами та відповідями. Наприклад, об’єкт Response можна
створювати вручну (через конструктор new Response(...)), а не лише отримувати з мережі. Це
робиться у сервіс-воркерах та інших низькорівневих сценаріях, де розробник сам хоче
керувати тим, що повертається у відповідь на певні запити, кешувати результати, підміняти
відповіді тощо. З теоретичної точки зору, API fetch є реалізацією так званої "Fetch Standard"
— окремої специфікації, яка описує, як саме мають поводитись запити, відповіді, заголовки,
статуси, перехоплення та перенаправлення, з урахуванням вимог безпеки й сумісності у веб-
середовищі.
З точки зору обробки помилок, важливо розрізняти кілька рівнів. На найнижчому рівні
знаходяться мережеві збої: втрата з’єднання, DNS-помилки, блокування запиту політикою
безпеки — у таких випадках fetch відхиляє проміс, і розробник повинен використовувати
try/catch або метод catch у ланцюжку промісів. На наступному рівні знаходяться помилки
протоколу HTTP: статуси 4xx і 5xx. Вони не зумовлюють відхилення промісу, але семантично
означають, що запит не був “успішним” з точки зору бізнес-логіки. Теоретично правильним є
явно перевіряти response.ok або конкретний response.status і вже в залежності від цього
формувати логіку: показувати повідомлення користувачу, повторювати запит, перенаправляти
на сторінку логіну тощо. На ще вищому рівні можна розглядати помилки формату даних:
наприклад, якщо очікувався JSON певної структури, але насправді сервер повернув інший
формат або напівпорожнє тіло — це вже логічна помилка на рівні прикладного протоколу між
клієнтом і сервером, яка також має бути відловлена окремо.Таким чином, з теоретичної точки
зору, fetch — це уніфікований, промісоорієнтований інтерфейс доступу до HTTP-ресурсів,
побудований на чітко визначених об’єктах (Request, Response, Headers, Body) і тісно
інтегрований із моделлю безпеки веб-браузера (same-origin policy, CORS, робота з
креденшіалами). Він не є “магією” для отримання JSON, а радше низькорівневою, але зручною
абстракцією над мережею, яка вимагає від розробника явного опрацювання статусів, форматів
даних, помилок і життєвого циклу запитів.
async function loadUsers() {
const res = await fetch("https://api.example.com/users");
if (!res.ok) {
throw new Error(`Request failed with status ${res.status}`);
}
const data = await res.json(); // парсимо тіло як JSON
console.log("Users:", data);
}
Більше інформації TS - https://www.typescriptlang.org/docs/, React - https://react.dev/learn
7.2 Підготовка до роботи
1. Встановити Node завантаживши інсталятор nodejs.org
2. За допомогою npm create vite@latest . -- --template react-ts створити новий проект.
(Використовуючи «.» проект буде створено в поточній папці) Обрати в запропонованих
інструкціях установки:
 «Select a framework ->React»;
 «Select a variant ->TypeScript»;
 «Userolldown-vite (Experemental) -> No»;
 «Install with npm and start now? -> Yes».
3. Запустити застосунок та видали зайві файли в src;
4. Встановити бібліотеку маршрутизації npm install react-router-dom;
5. Самостійно обрати дизайн та палітру кольорів для майбутнього веб-застосунку.
7.3 Порядок виконання роботи
1. Створити базову маршрутизацію на 4 сторінки, маршрути назвати відповідно:
 сторінка авторизації;
 сторінка реєстрації;
 сторінка авторизованого користувача - дашборд;
 сторінка 404;
2. Створити в src папки components, enums, interface, pages та реалізувати усі необхідні
компоненти.
3. Створити файл .env та записати глобальні змінні проекту: VITE_API_URL та інші.
4. Створити папку api та реалізувати усі запити до серверної частини (реєстрація
користувача, авторизація користувача, перевірка health_check).
5. Протестувати зв’язок серверної та клієнтської частини. При отримані такої помилки
як на рисунку 7.1, увімкнути CORS на серверній частині додатку та перезавантажити сервер.
Рис.7.1
6. Реалізувати редірект на дашборд після успішного логіну на сторінці .
7. Реалізувати перемикання між логіном та реєстрацією.
8. Після успішної реєстрації виводити повідомлення, що реєстрація успішна та
перекидувати на сторінку логіну, для його введення.
9. Реалізувати вивід помилок при заповнені форм.
10. Після завершення роботи створити Pull Request на Github та дочекатись схвалення
на об’єднання гілок.
7.4 Зміст звіту
1. Найменування і мета роботи;
2. Код по кожному пункту порядку виконання роботи;
3. Результати роботи по кожному пункту виконання роботи;
4. Висновки.
7.5 Контрольні запитання
1. Що таке fetch у JavaScript? Який тип значення він повертає?
2. Як за допомогою fetch реалізувати авторизацію, якщо сервер повертає токен доступу?
Які кроки потрібно виконати на клієнті?
3. Чому небажано викликати fetch безпосередньо в тілі компонента (поза useEffect) у
React?
4. Що таке CORS (Cross-Origin Resource Sharing) і як він впливає на роботу fetch у
браузері?
Додаток 1