Лабораторна робота №8
Відображення вимірювальної інформації у веб-застосунках
Мета: Ознайомитись з основними методами відображення інформації у веб-застосунка,
побудова діаграм з вимірювальною інформацією.
8.1 Теоретичні відомості
Параметри запиту URL-адреси – це параметри, що додаються до URL-адреси для
передачі додаткової інформації на сервер. Вони слідують за ? символом в URL-адресі та
розділяються символом &. Наприклад:
/greet?name=John&age=25
У цьому прикладі nameта age– це параметри запиту зі значеннями Johnта 25відповідно.
Параметри запиту дозволяють користувачам взаємодіяти з відповідями веб-сервера та
налаштовувати їх без зміни коду на стороні сервера.
Обидва типи параметрів передають дані до веб-застосунків, але вони виконують різні
ролі та використовуються в різних контекстах.
Параметри шляху є невід'ємною частиною URL-адреси та використовуються для
точного визначення конкретних ресурсів. Наприклад, в URL-адресі /users/123є 123
параметром шляху, який ідентифікує конкретного користувача. Використовуйте параметри
шляху для важливих, ієрархічних даних, що визначають ідентичність ресурсу.
Параметри запиту надають додаткову інформацію та йдуть після a ? в URL-адресі.
Наприклад, у /products?category=books&sort=price_asc, categoryта sort є параметрами запиту.
Вони ідеально підходять для додаткових даних, які налаштовують запит, таких як фільтри та
сортування.
Розуміння відмінностей допомагає вам вибрати правильний підхід: параметри шляху
для обов'язкових, специфічних для ресурсу даних та параметри запиту для необов'язкових,
настроюваних даних.
Flask спрощує обробку параметрів запитів URL-адрес за допомогою request модуля.
Ось простий приклад, який показує, як можна витягти параметри запиту за
допомогою request.args.get():
from flask import request
@app.route('/route', methods=['GET'])
def function():
# Extract the 'parameter_name' query parameter or use 'default_value' if not provided
variable = request.args.get('parameter_name', 'default_value')
У цьому прикладі ми імпортуємо request модуль з Flask для роботи з параметрами
запиту. Вам взагалі не потрібно змінювати декоратор маршруту. Просто витягніть значення
параметра запиту parameter_name за допомогою request.args.get('parameter_name',
'default_value'), який також встановлює значення за замовчуванням, якщо параметри не
передано. Давайте розберемо це детальніше:
requestМістить усі дані, пов'язані з HTTP-запитом, надісланим до сервера.
argsСтруктура, подібна до словника, всередині об'єкта request, яка містить параметри
запиту URL-адреси.
get: Отримує значення, пов'язане із зазначеним ключем (ім'я параметра запиту) у args, з
необов'язковим значенням за замовчуванням, якщо ключ відсутній.
Тепер створимо маршрут Flask, який приймає параметри запиту та відповідає JSON-
повідомленням.
from flask import Flask, jsonify, request
app = Flask(__name__)
@app.route('/greet', methods=['GET'])
def greet():
# Extract the 'name' query parameter or use a default value
name = request.args.get('name', 'Guest')
# Return a JSON response with the query parameter
return jsonify(message=f"Greetings, {name}! Welcome to the query parameter route.")
У цій функції маршруту request.args.get('name', 'Guest') використовується для
вилучення name параметра запиту, за замовчуванням встановлюючи значення , 'Guest' якщо
його не надано. Зрештою, функція повертає об'єкт JSON, який містить значення
параметра name.
8.2 Порядок виконання роботи
0. Створити окрему гілку в git;
1. Виконати злиття двох баз даних users.db та measurement.sqlite використовуючи код з
додатку 1. Після злиття перевірити коректність за допомогою SQlite-viewer
(https://inloop.github.io/sqlite-viewer/);
2. Зі сторони серверу додати ендпойнти :
- отримання списку існуючих локацій, де встановлені сенсори;
- отримання списку існуючих сенсорів;
- отримання списку існуючих сенсорів по локації;
- отримання даних вимірювань по сенсору (тільки час виміру ts);
- отримання даних вимірювання по сенсору в заданий інтервал часу from ts to ts;
3. Зі сторони клієнта реалізувати:
- інсталювати бібліотеку recharts та ознайомитись з документацією Recharts
(https://recharts.github.io/en-US/api/);
- створити захищений роут /dashboard на якому буде відображатись графік;
- на графіку потрібно реалізувати випадний список локацій;
- після вибору локації має бути доступний випадний список сенсорів, що встановлений
на вибраній локації;
- після вибору сенсору мають бути доступні 2 випадні списки часу вимірювань from to
- після введення усіх даних та натискання кнопки «show» має відображатись графік з
вибраними метриками (Температура, Вологість, Напруга, рівень CO, Освітленість, та рівень
NO₂) Приклад приведено в додатку 2;
4. Закомітити зміни та запушити на GitHub, cформувати PullRequest описати його(що
було виконано) та дочекатись схвалення викладача на merge.
8.3 Зміст звіту
1. Найменування і мета роботи;
2. Код по кожному пункту порядку виконання роботи;
3. Результати роботи по кожному пункту виконання роботи;
4. Висновки.
8.4 Контрольні запитання
1. Чим відрізняється path (/products/1) від query string (?page=2&limit=20)?
2. У яких випадках логічно використовувати path-параметр, а в яких – query-параметр?
3. Як кодуються спеціальні символи у query-рядку (пробіли, українські букви тощо)?
4. Чому важливо перевіряти та валідовувати значення query-параметрів (тип, діапазон,
обов’язковість) на бекенді? Наведи можливі наслідки відсутності такої валідації.
Додаток 1
import sqlite3
from pathlib import Path
USERS_DB = Path("backend/app/db/users.db")
MEAS_DB = Path("backend/app/db/measurement.sqlite")
def main():
conn = sqlite3.connect(USERS_DB)
cur = conn.cursor()
cur.execute("ATTACH DATABASE ? AS meas", (str(MEAS_DB),))
tables = cur.execute(
"""
SELECT name, sql
FROM meas.sqlite_master
WHERE type = 'table'
AND name NOT LIKE 'sqlite_%';
"""
).fetchall()
for name, create_sql in tables:
print(f"Обробляю таблицю: {name!r}")
exists = cur.execute(
"""
SELECT 1
FROM sqlite_master
WHERE type = 'table' AND name = ?;
""",
(name,),
).fetchone()
if not exists:
if create_sql:
print(f" Створюю таблицю {name!r} в users.db")
cur.execute(create_sql)
else:
print(f" Таблиця {name!r} вже існує в users.db, пропускаю CREATE TABLE")
try:
print(f" Копіюю дані з meas.{name} у {name}")
cur.execute(f"INSERT INTO {name} SELECT * FROM meas.{name};")
except sqlite3.Error as e:
print(f" ПОМИЛКА при копіюванні таблиці {name}: {e}")
conn.commit()
cur.execute("DETACH DATABASE meas")
conn.close()
if __name__ == "__main__":
main()
Додаток 2